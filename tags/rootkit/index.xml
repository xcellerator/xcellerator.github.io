<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rootkit on TheXcellerator</title>
    <link>/tags/rootkit/</link>
    <description>Recent content in rootkit on TheXcellerator</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Harvey Phillips 2020 - London, England</copyright>
    <lastBuildDate>Sun, 04 Oct 2020 12:00:00 +0100</lastBuildDate><atom:link href="/tags/rootkit/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux Rootkits Part 9: Hiding Logged In Users (Modifying File Contents Without Touching Disk)</title>
      <link>/posts/linux_rootkits_09/</link>
      <pubDate>Sun, 04 Oct 2020 12:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_09/</guid>
      <description>Let&amp;rsquo;s see if we can hide the fact that a user is logged in! The idea is that we&amp;rsquo;ll be able to spawn a shell or login in as some user (we&amp;rsquo;ll choose root) and not have it show up in the output of tools like who or finger.
Looking at the output of who, we see a list of all the active terminal devices and the users associated to them.</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 8: Hiding Open Ports</title>
      <link>/posts/linux_rootkits_08/</link>
      <pubDate>Fri, 02 Oct 2020 12:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_08/</guid>
      <description>Most userspace system tools just parse and manipulate data from one or more files and present them nicely to STDOUT. We&amp;rsquo;ve already seen this with processes (see Part 7), but this time we&amp;rsquo;re going to do the same thing with open ports. By the end, we&amp;rsquo;ll be able to open a listener on port 8080 (any port would do) without it showing up in things like netstat.
Assuming that a file is being read from, we need to try to find out which one.</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 7: Hiding Processes</title>
      <link>/posts/linux_rootkits_07/</link>
      <pubDate>Thu, 01 Oct 2020 12:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_07/</guid>
      <description>Now that we know how to hide directories (see last time), we can also hide processes! This is because nearly all userspace tools that give us information about processes just read the contents of the /proc/ filesystem. We can check this by looking at the output of strace -e openat ps or strace -e openat top. So, if we hide directories with the name of the PID we want to keep secret, then these userspace tools won&amp;rsquo;t notice that the process is there!</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 6: Hiding Directories</title>
      <link>/posts/linux_rootkits_06/</link>
      <pubDate>Sat, 19 Sep 2020 19:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_06/</guid>
      <description>At this point, we&amp;rsquo;ve used several different techniques to manipulate the kernel into doing interesting things. We&amp;rsquo;re going to combine a few of these techniques now in order to hide certain files and directories from userspace. This post is probably the most intricate yet due to the fact that we have to manipulate the structure returned by the kernel to userspace.
Roughly speaking, directory listing is handled by the syscall sys_getdents64 and its 32-bit counterpart sys_getdents (we&amp;rsquo;ll want to hook both, but they are identical except for a small addition in the 32-bit version).</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 5: Hiding Kernel Modules from Userspace</title>
      <link>/posts/linux_rootkits_05/</link>
      <pubDate>Thu, 17 Sep 2020 19:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_05/</guid>
      <description>So far, we&amp;rsquo;ve seen how hooking both syscalls and regular functions can be put to good use. But, seeing as how this is a series on rootkits, we should really be making some considerations on stealth. If you&amp;rsquo;ve been following along, then once you&amp;rsquo;d loaded any of the previous rootkits, it&amp;rsquo;s presence would have been revealed by simply examining the output of lsmod.
$ lsmod | grep rootkit rootkit 16384 0 Pretty obvious, right?</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 4: Backdooring PRNGs by Interfering with Char Devices</title>
      <link>/posts/linux_rootkits_04/</link>
      <pubDate>Wed, 09 Sep 2020 21:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_04/</guid>
      <description>We saw in Part 3 how easy it is to add some extra functionality to a syscall. This time we&amp;rsquo;re going to target a pair of kernel functions that are not syscalls, and can&amp;rsquo;t be called directly. To understand what these are, it&amp;rsquo;s worth discussing char devices a little first.
Char Devices in Linux Although you might not recognise the name, you&amp;rsquo;re probably already pretty familiar with a bunch of char (or chararacter) devices already.</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 3: A Backdoor to Root</title>
      <link>/posts/linux_rootkits_03/</link>
      <pubDate>Sat, 29 Aug 2020 21:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_03/</guid>
      <description>Now that you know how to make a Linux kernel module that can hook any exposed function in kernel memory (Part 1 and Part 2), let&amp;rsquo;s get down to writing a hook that does something interesting!
In this first example, we&amp;rsquo;re going to make a rootkit that intercepts calls to sys_kill. 99% of the time, we only use sys_kill (the userspace tool we normally use is the familiar kill) to kill a process, i.</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 2: Ftrace and Function Hooking</title>
      <link>/posts/linux_rootkits_02/</link>
      <pubDate>Wed, 26 Aug 2020 21:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_02/</guid>
      <description>Okay, so you&amp;rsquo;ve built your first kernel module, but now you want to make it do something cool - something like altering the behaviour of the running kernel. The way we do this is by function hooking, but the question is - how do we know which functions to hook?
Luckily for us, there is already a great list of potential targets: syscalls! Syscalls (or system calls) are kernel functions that can be called from userspace, and are required for almost anything remotely interesting.</description>
    </item>
    
    <item>
      <title>Linux Rootkits Part 1: Introduction and Worflow</title>
      <link>/posts/linux_rootkits_01/</link>
      <pubDate>Tue, 25 Aug 2020 21:00:00 +0100</pubDate>
      
      <guid>/posts/linux_rootkits_01/</guid>
      <description>Learning about Linux rootkits is a great way to learn more about how the kernel works. What&amp;rsquo;s great about it is that, unless you really understand what the kernel is doing, your rootkit is unlikely to work, so it serves as a fantasic verifier.
In the FreeBSD world, you can find Joseph Kong&amp;rsquo;s amazing book Designing BSD Rootkits. It was written in 2009, so is actually pretty outdated - which means that you have to do quite a bit of research to get the sample progras to work on modern FreeBSD.</description>
    </item>
    
  </channel>
</rss>
