<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>BGGP 4: How Low Can You Go? :: TheXcellerator</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Guess who&amp;rsquo;s back? The Binary Golf Grand Prix is back for it&amp;rsquo;s fourth annual outing! Sadly, after getting nerdsniped last year by the one and only @netspooky, I ended up not submitting an entry for last year&amp;rsquo;s competition (you can see what I got up to instead here).
This year, the theme was self replication. To avoid being sent active virii, the Binary Golf Association required that the entry created only a single copy of itself, and did not re-execute itself." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="/posts/bggp4/" />




<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/blue.css">






<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/img/favicon/blue.png">



<meta name="twitter:card" content="summary" />

<meta name="twitter:creator" content="" />


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="BGGP 4: How Low Can You Go? :: TheXcellerator">
<meta property="og:description" content="Guess who&amp;rsquo;s back? The Binary Golf Grand Prix is back for it&amp;rsquo;s fourth annual outing! Sadly, after getting nerdsniped last year by the one and only @netspooky, I ended up not submitting an entry for last year&amp;rsquo;s competition (you can see what I got up to instead here).
This year, the theme was self replication. To avoid being sent active virii, the Binary Golf Association required that the entry created only a single copy of itself, and did not re-execute itself." />
<meta property="og:url" content="/posts/bggp4/" />
<meta property="og:site_name" content="BGGP 4: How Low Can You Go?" />

  
    <meta property="og:image" content="/img/favicon/blue.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

  <meta property="article:section" content="reverse_engineering" />

  <meta property="article:section" content="other" />


  <meta property="article:published_time" content="2023-09-23 12:00:00 &#43;0100 BST" />












</head>
<body class="">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    TheXcellerator
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/categories/cryptography/">Cryptography</a></li>
        
      
        
          <li><a href="/categories/linux/">Linux</a></li>
        
      
        
          <li><a href="/categories/other/">Other</a></li>
        
      
        
          <li><a href="/categories/reverse_engineering/">Reverse Engineering</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/categories/cryptography/">Cryptography</a></li>
      
    
      
        <li><a href="/categories/linux/">Linux</a></li>
      
    
      
        <li><a href="/categories/other/">Other</a></li>
      
    
      
        <li><a href="/categories/reverse_engineering/">Reverse Engineering</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/bggp4/">BGGP 4: How Low Can You Go?</a></h1>
  <div class="post-meta">
      
    <span class="post-date">
      2023-09-23
    </span>
    
    
  </div>

  

  

  <div class="post-content"><div>
        <h1 id="guess-whos-back">Guess who&rsquo;s back?<a href="#guess-whos-back" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>The Binary Golf Grand Prix is back for it&rsquo;s fourth annual outing! Sadly, after getting nerdsniped last year by the one and only <a href="https://haunted.computer/@netspooky">@netspooky</a>, I ended up not submitting an entry for last year&rsquo;s competition (you can see what I got up to instead <a href="../tetsuji">here</a>).</p>
<p>This year, the theme was <a href="https://binary.golf/"><em>self replication</em></a>. To avoid being sent active virii, the Binary Golf Association required that the entry created only a <em>single</em> copy of itself, and did not re-execute itself.</p>
<p>Simply creating a copy of yourself isn&rsquo;t by itself very hard, but doing so in very few bytes poses as interesting challenge. In the end, I came up with three different entry ideas. You might not be interested in all three, so here are some quick links:</p>
<ul>
<li><a href="#idea-1-commodore-64-prg">Commodore 64 PRG</a></li>
<li><a href="#idea-2-python-zip">Python ZIP</a></li>
<li><a href="#idea-3-risc-v-elf">RISC-V ELF</a></li>
</ul>
<p>All the code can be found on my GitHub <a href="https://github.com/xcellerator/bggp4">here</a>.</p>
<h1 id="idea-1-commodore-64-prg">Idea 1: Commodore 64 PRG<a href="#idea-1-commodore-64-prg" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>My initial idea was for a C64 BASIC program that looked something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-basic" data-lang="basic"><span style="display:flex;"><span>1 <span style="color:#66d9ef">PRINT</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>2 SAVE <span style="color:#e6db74">&#34;4&#34;</span>,<span style="color:#ae81ff">8</span>
</span></span></code></pre></div><p>Clearly this would both print a <code>4</code> (as required by the <a href="https://binary.golf/">rules</a>), and save a copy of itself (titled <code>4</code>) to diskette. This already seems pretty small, but is there any room for golfing once we get down to the bytes?</p>
<p>In order to verify the checksums of the original and copied file, I had to figure out how to get a copy of the &ldquo;file&rdquo; as the C64 sees it. To do that, I used the <a href="https://vice-emu.sourceforge.io/">VICE</a> emulator and created a C64 virtual disk image to attach to the running machine. I entered the above BASIC into the C64 and then ran <code>SAVE &quot;BGGP&quot;,8</code>. After shutting the machine off and looking at the resulting <code>d64</code> file, I was presented with another issue - it was 171KB in size.</p>
<p>Now, I don&rsquo;t want to golf the disk image itself, just the program that&rsquo;s on the disk. I&rsquo;d read before about how floppy disks were laid out physically in terms of sectors and tracks, but now was the time to dive in as I need to be able to prove that the two files on the disk (the original <code>BGGP</code> and subsequent <code>4</code> that&rsquo;s created) are identical.</p>
<h2 id="detour-d64-image-files">Detour: D64 Image Files<a href="#detour-d64-image-files" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The most common file format for representing 5.25&quot; floppy disks seems to be <code>D64</code> and is indeed what the VICE emulator defaults to. Looking at the <a href="https://vice-emu.sourceforge.io/vice_17.html#SEC405">VICE documentation</a> we can start to get an idea of how they&rsquo;re laid out.</p>
<p>The first thing to understand is that information is encoded on floppy disks in a <em>circular</em> pattern. Why does this matter? Well, if each bit takes up the same amount of physical space (roughly speaking), then you can clearly fit more bits into a ring that&rsquo;s closer to the edge of the floppy than one that&rsquo;s closer to the center.</p>
<p>You may already be aware that data on a floppy is broken up into 256-byte sectors (the term <em>boot sector</em> is still used today!). We group sectors into &ldquo;tracks&rdquo;, which are arranged in a spiral from the outer edge of the disk. In order to solve the spacing problem I mentioned above, we have to adjust the number of sectors per track. As the tracks get closer to the center of the disk, they are literally shorter, so we can fit fewer sectors on them.</p>
<p>Putting it all together, a standard 5.25&quot; floppy disk has 683 sectors for a total of 174,848 bytes. The sectors are arranged into tracks in the following way:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Track</th>
<th style="text-align:center">Sectors Per Track</th>
<th style="text-align:center">Cumulative Sector Count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1 - 17</td>
<td style="text-align:center">21</td>
<td style="text-align:center">357</td>
</tr>
<tr>
<td style="text-align:center">18 - 24</td>
<td style="text-align:center">19</td>
<td style="text-align:center">490</td>
</tr>
<tr>
<td style="text-align:center">25 - 30</td>
<td style="text-align:center">18</td>
<td style="text-align:center">598</td>
</tr>
<tr>
<td style="text-align:center">31 - 35</td>
<td style="text-align:center">17</td>
<td style="text-align:center">683</td>
</tr>
</tbody>
</table>
<p>One awkward wrinkle we have to keep in mind when parsing a D64 file: track numbering starts at <code>1</code>, whereas sector numbering starts at <code>0</code>, i.e. the first sector on the disk is <em>track 1, sector 0</em>.</p>
<p>With the physical layout of sectors out the way, how do we go about finding what&rsquo;s actually on the disk? Things like file names and sizes? Well, Commodore decided that track 18 is special - it&rsquo;s the <em>directory track</em>.</p>
<p>The directory track begins with a sector dedicated to the <em>Block Availability Map</em> (BAM) with subsequent sectors being individual directory entries. An important point here is that we only have 18 sectors available for directory entries. A single entry is 32 bytes long, which means we get 8 entries per sector, leading us to a limit of <code>18*8 = 144</code> entries per disk. By today&rsquo;s standards, that&rsquo;s not much - but it was surely a different story back in 1982!</p>
<p>This is the format of the BAM. Note that track/sector pairs are often written as <code>x/y</code>, e.g. <code>18/1</code> refers to the track 18, sector 1.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> bam {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Location of first directory sector.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// This is usually ignored and first entry is is assumed to be 18/1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> first_track;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> first_sector;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// DOS version type. Anything other than $00 or $41 implies write protection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $02
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> dos_version;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $03
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// BAM entries for each track (see further down).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// There are 35 tracks with each BAM entry is 4 bytes long, totalling 140 bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $04
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> dir_entry_map entries[<span style="color:#ae81ff">35</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Disk Name (padding byte is $a0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $90
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> disk_name[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused (set to $a0 on real disks)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $a0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused2[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Disk ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $a2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> disk_id;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused (usually set to $a0 on real disks)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $a4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// DOS Type (usually $32 $41 == &#34;2A&#34;)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $a5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> dos_type[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused (usually set to $a0 on real disks)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $a7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused4[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused (usually set to $00 on real disks)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $ab
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused5[<span style="color:#ae81ff">85</span>];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> dir_entry_map {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> free_sectors;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Free Sector Bitmasks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> sector00: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector01: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector02: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector03: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector04: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector05: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector06: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector07: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector08: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector09: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector10: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector11: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector12: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector13: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector14: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector15: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector16: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector17: <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> sector18: <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// Only for tracks &lt;31
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> sector19: <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// Only for tracks &lt;25
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> sector20: <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// Only for tracks &lt;18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> sector21: <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// Only for tracks &lt;18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Oof, that&rsquo;s quite a lot. Those bitmasks are pretty fiddly in Python too, but fortunately the <a href="https://vice-emu.sourceforge.io/vice_17.html#SEC405">VICE documentation</a> gives an example BAM and BAM entry so we can make sure that everything gets parsed as we expect.</p>
<p>Let&rsquo;s gather our thoughts. As mentioned, we have a disk with a bunch of tracks. Each track has some number of 256-byte sectors. Track 18 is special because it&rsquo;s first sector is the <em>block availability map</em> (BAM) which (for the most part) contains a bitmap of the free sectors on each track.</p>
<p>The rest of the directory track (track 18) is composed of <em>directory entries</em>. This is where the actual files and their sizes are specified. The directory entry is <em>fairly</em> simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> dir_entry {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Track and sector of next directory entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> next_dir_entry;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// File Type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 0 =&gt; DEL   &#34;Deleted File&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 1 =&gt; SEQ   &#34;Sequential File&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 2 =&gt; PRG   &#34;Program File&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 3 =&gt; USR   &#34;User File&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// 4 =&gt; REL   &#34;Relative File&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $02
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> file_type :<span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> unused    :<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> xxx       :<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> locked    :<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> closed    :<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Track and sector of first sector of the file data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $03
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> first_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Filename (PETSCII), padded with $a0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $05
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> filename[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Track and sector of first side-sector block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Only for REL files
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $15
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> first_side_sector;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// File record length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Only for REL files
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $17
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> file_record_length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $18
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// File size in sectors
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// Offset $1e
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> file_sector_size;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Fortunately, I&rsquo;m not interested in a fair amount of these fields (remember - I only want to parse this file enough to read out filenames and calculate sha256sums of the contents).</p>
<p>At this point, we know what to do:</p>
<ol>
<li>Break out the disk image into tracks, with each track broken up into sectors</li>
<li>Parse track 18/sector 0 as the block availability map to determine which sectors are being used</li>
<li>Parse the directory entires to know what files are on the disk and what the filenames are</li>
<li>Resolve each file to their relevant sector(s)</li>
<li>Compute sha256 hashes of each file</li>
</ol>
<p>If we give it a go with the <code>BGGP</code> file currently on the disk, we see:</p>
<pre tabindex="0"><code>$ ./d64.py disk.d64
+----------------------------------------------------------------------------------------------------------+
|                                            Files on Disk &#34; &#34;                                             |
+----------+-----------+-------+--------+------------------------------------------------------------------+
| Filename | Sector(s) | Track | Sector |                            Sha256Sum                             |
+----------+-----------+-------+--------+------------------------------------------------------------------+
|   BGGP   |     1     |   17  |   0    | 419fa20ffd1f6baf878525252a8d255b8695ba2ebf2b76b8cfab03a53309c9bd |
+----------+-----------+-------+--------+------------------------------------------------------------------+
</code></pre><h2 id="back-to-basic">Back to BASIC<a href="#back-to-basic" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Now that we can parse the <code>d64</code> image to see the file(s) inside, we can get back to golfing the PRG file - so, what&rsquo;s the structure?</p>
<ul>
<li>
<p>The first 2 bytes form a little endian pointer to the location that the PRG expects to be loaded at. This can be ignored by the C64 <code>LOAD</code> instruction if we set the (optional) second argument to <code>1</code>. I made use of this option <a href="../bggp21/#commodore64-prg">two years ago for BGGP 2</a>, but seeing as we can&rsquo;t avoid having these two bytes in the file, we might as well as set them to the default value of <code>$8001</code>.</p>
</li>
<li>
<p>The next two bytes are another little endian pointer, but this time to the <em>second line of BASIC</em>. The first line of BASIC immediately follows these two bytes.</p>
</li>
<li>
<p>Now, we have a line of BASIC.</p>
<ul>
<li>Two bytes for a line number, e.g. <code>0a 00</code> for line <code>10</code>.</li>
<li>A <a href="https://www.c64-wiki.com/wiki/BASIC_token">BASIC token</a> identifying which instruction this is, e.g. <code>PRINT</code>, <code>SAVE</code>, etc</li>
<li>The arguments to the BASIC instruction in <a href="https://sta.c64.org/cbm64pet.html">PETSCII</a> (PETSCII has enough overlap with ASCII that we can usually pretend it&rsquo;s just ASCII, as you&rsquo;ll see)</li>
</ul>
</li>
</ul>
<p>Let&rsquo;s see an example. The first line of BASIC in our PRG so far is <code>1 PRINT 4</code>, this ends up being:</p>
<pre tabindex="0"><code class="language-hex" data-lang="hex">01 00 99 34 00
┃     ┃  ┃
┃     ┃  ┗━━━━━ &#34;4\0&#34;: Null-terminated 4 in PETSCII
┃     ┗━━━━━━━━ BASIC Token $99 = PRINT
┗━━━━━━━━━━━━━━ Line Number $0001 = 1
</code></pre><p>Fairly simple, right? Likewise, the second (and final) line of BASIC is <code>2 SAVE &quot;4&quot;,8</code> which is just:</p>
<pre tabindex="0"><code class="language-hex" data-lang="hex">02 00 94 22 34 22 2c 38 00
┃     ┃  ┃
┃     ┃  ┗━━━━━━━━━━━━━━━━━ &#39;&#34;4&#34;,8\0&#39;: Null-terminated &#34;4&#34;,8 in PETSCII
┃     ┗━━━━━━━━━━━━━━━━━━━━ BASIC Token $94 = SAVE
┗━━━━━━━━━━━━━━━━━━━━━━━━━━ Line Number $0002 = 2
</code></pre><p>So, now our PRG looks like:</p>
<pre tabindex="0"><code class="language-hex" data-lang="hex">01 08 08 08 01 00 99 34 00 13 08 02 00 94 22 34 22 2c 38 00 00 00 00 00
┃     ┃     ┃              ┃     ┃                          ┃     ┃
A     B     C              D     E                          F     G
</code></pre><table>
<thead>
<tr>
<th>Label</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td><code>$0801</code> is the pointer to the start of BASIC RAM (the default load location for PRGs)</td>
</tr>
<tr>
<td>B</td>
<td><code>$0808</code> is the pointer to the <em>second</em> line of BASIC</td>
</tr>
<tr>
<td>C</td>
<td>Basic Line 1: <code>1 PRINT 4</code></td>
</tr>
<tr>
<td>D</td>
<td><code>$0813</code> is the pointer to the <em>third</em> line of BASIC (which doesn&rsquo;t exist!)</td>
</tr>
<tr>
<td>E</td>
<td>Basic Line 2: <code>2 SAVE &quot;4&quot;,8</code></td>
</tr>
<tr>
<td>F</td>
<td><code>$0000</code> is the null pointer indicating that there are no more lines of BASIC</td>
</tr>
<tr>
<td>G</td>
<td>We end with two null bytes to show this &ldquo;third&rdquo; line of BASIC is empty</td>
</tr>
</tbody>
</table>
<p>Sadly, it seems that there really isn&rsquo;t much to golf in the PRG format (though I&rsquo;d love to be proven wrong!). The only thing I changed was removing a few unnecessary spaces from the BASIC arguments. However, it was a fun learning exercise and gave me an excuse to figure out how tracks and sectors really worked on floppy disks.</p>
<p>Once we run the PRG and re-examine the D64 image file, we see:</p>
<pre tabindex="0"><code>$ ./d64.py disk.d64
+----------------------------------------------------------------------------------------------------------+
|                                            Files on Disk &#34; &#34;                                             |
+----------+-----------+-------+--------+------------------------------------------------------------------+
| Filename | Sector(s) | Track | Sector |                            Sha256Sum                             |
+----------+-----------+-------+--------+------------------------------------------------------------------+
|   BGGP   |     1     |   17  |   0    | 419fa20ffd1f6baf878525252a8d255b8695ba2ebf2b76b8cfab03a53309c9bd |
|    4     |     1     |   17  |   1    | 419fa20ffd1f6baf878525252a8d255b8695ba2ebf2b76b8cfab03a53309c9bd |
+----------+-----------+-------+--------+------------------------------------------------------------------+
</code></pre><p>Below is the final <code>BGGP</code> file, totalling 20 bytes.</p>
<pre tabindex="0"><code>┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 01 08 08 08 01 00 99 34 ┊ 00 13 08 02 00 94 22 34 │•••••⋄×4┊⋄•••⋄×&#34;4│
│00000010│ 22 2c 38 00             ┊                         │&#34;,8⋄    ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘
</code></pre><h1 id="idea-2-python-zip">Idea 2: Python ZIP<a href="#idea-2-python-zip" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>Did you know that Python can execute ZIP files directly? I certainly didn&rsquo;t until a friend told me. This gave me an idea to try golfing a Python-executable ZIP file.</p>
<p>ZIP files are fairly simple beasts, apart from the oft-quoted fact that they&rsquo;re &ldquo;parsed backwards&rdquo;. What this means is that a ZIP candidate is scanned from the end of the file backwards until the parser finds the magic of the &ldquo;End Of Central Directory&rdquo; structure - from there it can continue to parse the rest of the file via file offsets.</p>
<p>This &ldquo;end of central directory&rdquo; structure looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> PKZipEndOfCentralDirectory {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 0x50 0x4b 0x05 0x06
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> magic[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused1[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Number of file entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> file_entries;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Size of the Central Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint32_t</span> central_directory_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// File offset to the Central Directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint32_t</span> central_directory_offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> unused2[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So, once we&rsquo;ve got the <em>end</em> of the central directory, we can follow the <code>central_directory_offset</code> to the <em>start</em> of the central directory. This can be anywhere in the file and it details all the files that are in this ZIP.</p>
<p>Similarly, the central directory itself is fairly straightforward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> PKZipStartOfCentralDirectory {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 0x50 0x4b 0x01 0x02
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> magic[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused1[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Compression Method (0 = NONE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> compression_method;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused2[<span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Compressed File Size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint32_t</span> compressed_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Uncompressed File Size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint32_t</span> uncompressed_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Filename Size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> filename_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Extra Field Size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> extra_field_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// File Comment Size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> file_comment_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused3[<span style="color:#ae81ff">8</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// File offset to the File Header
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint32_t</span> file_header_offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Filename
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> filename[filename_size];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There may be several file entries, but for a Python-ZIP, we only need one, but the filename <em>must</em> be <code>__main__.py</code> so that Python knows to begin execution here.</p>
<p>Lastly, you&rsquo;ll see that there&rsquo;s a file offset to something called the &ldquo;File Header&rdquo;. This is the last header we care about, and looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> PKZipFileHeader {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 0x50 0x4b 0x03 0x04
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> magic[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Unused
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> unused[<span style="color:#ae81ff">22</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Filename Size
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint32_t</span> filename_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Filename
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">char</span> filename[filename_size];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// File Contents
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint8_t</span> file_contents[...];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can probably see, the size of <code>file_contents</code> will come from the <code>compressed_size</code> field of <code>PKZipStartOfCentralDirectory</code>. One handy trick here (and the only real golfing trick I could find!) is that you don&rsquo;t have to re-define the filename in the file header. You can simply set <code>filename_size</code> to <code>0</code> in <code>PKZipFileHeader</code> and omit the <code>filename</code> field altogether, going straight to the <code>file_contents</code>.</p>
<blockquote>
<p>An interesting point here as well is that the Python required to both print <code>4</code> and make a copy of ourself is below the threshold of compression gains for the methods supported by PKZIP. This means that we actually <em>save bytes</em> by <em>NOT</em> compressing the file contents.</p>
</blockquote>
<p>So, what are we going to use for our file contents? Admittedly, I didn&rsquo;t try very hard to make this super small as this file format doesn&rsquo;t seem to offer many avenues for golfing (I&rsquo;m sure another BGGP entry this year will come up with some smaller Python).</p>
<p>The string I settled on is simply:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> os;print(<span style="color:#e6db74">&#39;4&#39;</span>);os<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#39;cp a 4&#39;</span>)
</span></span></code></pre></div><p>which has the obvious downside that the file must be named <code>a</code> in order for this to work (importing <code>sys</code> just to get <code>argv[0]</code> seemed like too many bytes to justify).</p>
<p>Putting it all together, this is the resulting file:</p>
<pre tabindex="0"><code>┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 50 4b 03 04 58 58 58 58 ┊ 58 58 58 58 58 58 58 58 │PK••XXXX┊XXXXXXXX│
│00000010│ 58 58 58 58 58 58 58 58 ┊ 58 58 00 00 00 00 69 6d │XXXXXXXX┊XX⋄⋄⋄⋄im│
│00000020│ 70 6f 72 74 20 6f 73 3b ┊ 70 72 69 6e 74 28 27 34 │port os;┊print(&#39;4│
│00000030│ 27 29 3b 6f 73 2e 73 79 ┊ 73 74 65 6d 28 27 63 70 │&#39;);os.sy┊stem(&#39;cp│
│00000040│ 20 61 20 34 27 29 50 4b ┊ 01 02 58 58 58 58 58 58 │ a 4&#39;)PK┊••XXXXXX│
│00000050│ 00 00 58 58 58 58 58 58 ┊ 58 58 28 00 00 00 28 00 │⋄⋄XXXXXX┊XX(⋄⋄⋄(⋄│
│00000060│ 00 00 0b 00 00 00 00 00 ┊ 58 58 58 58 58 58 58 58 │⋄⋄•⋄⋄⋄⋄⋄┊XXXXXXXX│
│00000070│ 00 00 00 00 5f 5f 6d 61 ┊ 69 6e 5f 5f 2e 70 79 50 │⋄⋄⋄⋄__ma┊in__.pyP│
│00000080│ 4b 05 06 58 58 58 58 58 ┊ 58 01 00 39 00 00 00 46 │K••XXXXX┊X•⋄9⋄⋄⋄F│
│00000090│ 00 00 00 58 58          ┊                         │⋄⋄⋄XX   ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘
</code></pre><h1 id="idea-3-risc-v-elf">Idea 3: RISC-V Elf<a href="#idea-3-risc-v-elf" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>ELF golfing is not new. In fact, BGGP Chief Organizer <a href="https://haunted.computer/@netspooky">@netspooky</a> is an authority on the subject. However, I&rsquo;d been spending some time with RISC-V and it got me wondering about how the ISA change from x86_64 could impact golf-ability.</p>
<p>To start off, I needed a convenient way to run RISC-V ELFs and Ubuntu conveniently offer a <a href="https://ubuntu.com/download/risc-v">preinstalled image ready for QEMU</a>. Once that was up and running, I used the same technique as described in <a href="https://tmpout.sh/1/1.html">tmp0ut 1:1</a> to create a minimum viable ELF. That article also describes which entries in the ELF and program headers are ignored by the kernel&rsquo;s ELF loader.</p>
<p>To make editing easier, I ended up transcribing this ELF into a nasm file. <a href="https://haunted.computer/@netspooky">@netspooky</a>&rsquo;s excellent series on <a href="https://n0.lol/ebm/1.html">ELF Binary Mangling</a> is a great place to start if you&rsquo;ve never done that before.</p>
<p>With the rough ELF outline done, I had to actually write some RISC-V assembly to meet the <a href="https://binary.golf">BGGP 4</a> entry requirements; namely to print or return <code>4</code> and create a copy of ourself.</p>
<p>Clearly, the way to achieve these goals in the least amount of bytes is with syscalls, which means we need to know how to call them on RISC-V. If you&rsquo;ve ever done syscall programming in the past on another ISA, this will likely feel very familiar to you.</p>
<p>RISC-V&rsquo;s registers can be referred to either by their &ldquo;real&rdquo; name (which runs <code>x0</code> to <code>x31</code>) or by their ABI name (which is far more convenient). The ABI registers for function arguments are <code>a0</code> through <code>a7</code> with the return value being put in <code>a0</code>. All the <code>a*</code> registers are saved by the <em>caller</em>.</p>
<p>On Linux, the syscall number is put in register <code>a7</code> and the arguments going into <code>a0</code>-<code>a6</code>. We jump into the kernel to perform the syscall using the <code>ecall</code> instruction.</p>
<p>With that, the order of syscalls is what we&rsquo;d expect:</p>
<ol>
<li><code>fd = SYS_OPENAT( AT_FWCD, &quot;4&quot;, O_WRONLY|O_CREAT, O_WRONLY)</code></li>
<li><code>SYS_WRITE(fd, LOADADDR, BINSIZE)</code></li>
<li><code>SYS_CLOSE(fd)</code></li>
<li><code>SYS_EXIT(4)</code></li>
</ol>
<p>Where <code>LOADADDR</code> is the load address of the ELF in virtual memory and <code>BINSIZE</code> is the size of the file.</p>
<blockquote>
<p>In order to calculate the <code>LOADADDR</code> value, we can just subtract a precalculated value from <code>pc</code>. However, this requires that the <em>entire ELF</em> is loaded into memory. The way to do this is to set the <code>p_offset</code> field of the program header to <code>0x0</code> rather than to the offset of the start of the text segment. This is also reflected in the value of the <code>e_entry</code> field of the ELF header being set to the <em>file offset</em> of the first instruction.</p>
</blockquote>
<p><em>However</em>, we don&rsquo;t actually have to call <code>SYS_CLOSE</code> because the kernel will handle that for us once we call <code>SYS_EXIT</code> automatically, so let&rsquo;s forget about closing the file.</p>
<p><a href="https://www.robalni.org/riscv/linux-syscalls-64.html">Looking up the syscalls</a>, we find that they are:</p>
<ul>
<li><code>SYS_OPENAT</code> = <code>56</code></li>
<li><code>SYS_WRITE</code> = <code>64</code></li>
<li><code>SYS_EXIT</code> = <code>93</code></li>
</ul>
<p>Let&rsquo;s start writing some RISC-V assembly but stay aware of possible savings as we go. To do that, we need to know a couple of things about RISC-V compressed instructions.</p>
<h2 id="risc-v-compressed-instructions">RISC-V Compressed Instructions<a href="#risc-v-compressed-instructions" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>RISC-V is an ISA with <a href="https://en.wikichip.org/wiki/risc-v/standard_extensions">many possible extensions</a>. One of the most common (and in our case, most useful) is the <code>C</code> extension which stands for &ldquo;Compression&rdquo;. If you&rsquo;re familar with (or even just heard of) ARM&rsquo;s Thumb mode, this will be familiar to you. Ordinarily, RISC-V instructions are 32 bits wide, but in certain circumstances there are 16-bit instructions that achieve the same thing if your CPU has the <code>C</code> extension. The really cool thing about this extension is that it&rsquo;s implicit from the instruction whether it&rsquo;s 32-bit or 16-bit! This means that you don&rsquo;t have to jump to an address with the LSB set or anything similar like you have to with Thumb mode on ARM. This is also really useful from a golfing standpoint because it means we can mix compressed and non-compressed instructions however we like!</p>
<p>Before we start writing our RISC-V assembly, we should know when the assembler will emit compressed instructions over non-compressed ones. To better understand this, we can use the <a href="https://riscv.org/wp-content/uploads/2015/11/riscv-compressed-spec-v1.9.pdf">specification</a>. Of particular interest will be add immediate and load immediate instructions because that&rsquo;s what our code will mostly be comprised of.</p>
<p>Jumping to page 10 of the spec, we find that the <code>c.li</code> instruction will load a sign-extended 6-bit immediate into a register. This means that we will only get a compressed load immediate if the immediate is <code>&lt;= 31</code>. Reading on towards the end of page 10, we see that the same restriction applies to the <code>c.addi</code> instruction as well.</p>
<p>The other compressed instruction we will want to optimise for is the <code>c.j</code> compressed jump. On page 9 of the spec, we discover that 11-bits of the <code>c.j</code> instruction are used as another sign-extended integer which is added to <code>pc</code>. It also conveniently informs us that this corresponds to a range of <code>±2KiB</code>, which is enough that we actually <em>shouldn&rsquo;t</em> have to worry (however, we&rsquo;ll see that we really do have to worry but for different reasons).</p>
<h2 id="back-to-assembly">Back to Assembly<a href="#back-to-assembly" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Armed with this newfound knowledge, we can start writing some RISC-V assembly. It&rsquo;ll be useful to have the <a href="https://riscv.org/wp-content/uploads/2019/06/riscv-spec.pdf">RISC-V Specification</a> open as we go.</p>
<p>The first thing we have to do is set up the <code>SYS_OPENAT</code> syscall to open the file for writing. The manpage (<code>man 2 openat</code>) helpfully informs us that it has the prototype:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">openat</span>(<span style="color:#66d9ef">int</span> dirfd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pathname, <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">mode_t</span> mode);
</span></span></code></pre></div><ul>
<li>The first argument (in <code>a0</code>) <code>dirfd</code> needs to be set to <code>AT_FDCWD</code> (defined in <code>fcntl.h</code> as <code>-100</code>) to indicate that we&rsquo;re using the CWD and that <code>pathname</code> is a relative path</li>
<li>The second argument (in <code>a1</code>) <code>pathname</code> needs to be a pointer to the filename <code>&quot;4\0&quot;</code></li>
<li>The third argument (in <code>a2</code>) <code>flags</code> must be set to <code>O_CREAT | O_WRONLY</code> (defined in <code>fcntl.h</code> as <code>64</code> and <code>1</code> respectively)</li>
<li>The fourth argument (in <code>a3</code>) <code>mode</code> just has to be <code>O_WRONLY</code> (<code>1</code>)</li>
</ul>
<p>Most of these are easy to set, except for the <code>pathname</code> pointer in <code>a1</code>. It&rsquo;s easy enough to put the string <code>4\0</code> in our binary somewhere, but how do we get a pointer to it? Fortunately, RISC-V provides an instruction to help us: <code>auipc</code>, &ldquo;Add Upper Immediate to PC&rdquo;. This instruction takes a register and a 20-bit immediate. It then shifts the 20-bit immediate left 12 bits and adds this resulting number to <code>pc</code> before storing it in the register provided. In our case, <code>auipc a1, 0</code> will simply put <code>pc</code> in the register <code>a1</code> (this is the only RISC-V way of obtaining the value in <code>pc</code>!). Once we know where execution is in our binary, we can add/subtract a relative offset to get a pointer to <code>4\0</code> in the register <code>a1</code>.</p>
<p>So, our <code>SYS_OPENAT</code> call is going to look <em>something like this</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a0</span>, -<span style="color:#ae81ff">100</span>             <span style="color:#75715e">; Put AT_FDCWD into a0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">auipc</span> <span style="color:#66d9ef">a1</span>, <span style="color:#ae81ff">0</span>             <span style="color:#75715e">; Put PC into a1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addiw</span> <span style="color:#66d9ef">a1</span>, <span style="color:#66d9ef">a1</span>, <span style="color:#960050;background-color:#1e0010">+??</span>       <span style="color:#75715e">; Add ?? to a1                      ; 16-bits if ?? &lt;= 31
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a2</span>, <span style="color:#ae81ff">65</span>               <span style="color:#75715e">; Put O_CREAT | O_WRONLY into a2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a3</span>, <span style="color:#ae81ff">1</span>                <span style="color:#75715e">; Put O_WRONLY into a3              ; 16-bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">56</span>               <span style="color:#75715e">; Put SYS_OPENAT into a7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ecall</span>                   <span style="color:#75715e">; Do syscall
</span></span></span></code></pre></div><p>Fairly simple, right? Well, that&rsquo;s the hard one out the way already. Before we continue, let&rsquo;s think about what values are in the registers after the <code>ecall</code> instruction.</p>
<ul>
<li><code>a0</code> will contain the return value of <code>SYS_OPENAT</code>, i.e. the file descriptor</li>
<li><code>a1</code> will still contain a pointer to the <code>pathname</code></li>
<li><code>a2</code> will still contain <code>65</code> (<code>O_CREAT | O_WRONLY</code>)</li>
<li><code>a4</code> will still contain <code>1</code> (<code>O_WRONLY</code>)</li>
</ul>
<p>The prototype for <code>SYS_WRITE</code> is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> buf[.count], <span style="color:#66d9ef">size_t</span> count);
</span></span></code></pre></div><p>We don&rsquo;t need to touch <code>a0</code> at all - it already contains the file descriptor! The <code>buf</code> argument in <code>a1</code> needs to be set to the start of the ELF in virtual memory. Luckily, we already have a pointer to somewhere in the ELF in <code>a1</code> (specifically to the <code>pathname</code>), so we can just pre-calculate an offset to the start of the ELF header and subtract it from <code>a1</code>. Lastly, we need the total size of the binary in <code>a2</code>. This is a little tricky.</p>
<p>We want to make as much use of compressed instructions as possible, but the total size of the binary is going to be more than 31 bytes more than the <code>65</code> we already have in <code>a2</code>. Is there anything we can do avoid using a full-width instruction?</p>
<p>So, it turns out that the <code>SYS_OPENAT</code> syscall checks the value in <code>a2</code> by <code>OR</code>ing it against the various flags it knows about. This means that we can put a value other than <code>65</code> into <code>a2</code> and, as long as it <code>OR</code>s true with both <code>O_CREAT</code> and <code>O_WRONLY</code>, the syscall will still work! We can use this to our advantage by putting a larger value into <code>a2</code> using the full-width <code>li</code> we&rsquo;re already stuck with, and then get away with using a compressed 16-bit wide instruction in preparation for <code>SYS_WRITE</code>!</p>
<p>Lastly, the jump from <code>56</code> (<code>SYS_OPENAT</code>) to <code>64</code> (<code>SYS_WRITE</code>) in the <code>a7</code> register is already small enough to be a compressed instruction.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">addi</span> <span style="color:#66d9ef">a1</span>, <span style="color:#66d9ef">a1</span>, -<span style="color:#960050;background-color:#1e0010">??</span>        <span style="color:#75715e">; Subtract ?? from a1 to get a pointer to the start of the ELF  ; 16-bits if ?? &lt;= 31
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addi</span> <span style="color:#66d9ef">a2</span>, <span style="color:#66d9ef">a2</span>, <span style="color:#960050;background-color:#1e0010">??</span>         <span style="color:#75715e">; Add ?? to a2 to get the total file size                       ; 16-bits if ?? &lt;= 31
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addiw</span> <span style="color:#66d9ef">a7</span>, <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">8</span>         <span style="color:#75715e">; Add 8 to a7 to get 64 (SYS_WRITE)                             ; 16-bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ecall</span>                   <span style="color:#75715e">; Do syscall
</span></span></span></code></pre></div><p>Okay, we&rsquo;re gradually getting somewhere, but still leaving a lot of values to be filled in later on. The final thing we need to do is do the <code>SYS_EXIT</code> syscall. We have no choice but to use a full-width load to get <code>4</code> into <code>a0</code>, but then we can use a compressed <code>addiw</code> to add <code>29</code> to <code>a7</code> in order to get <code>93</code> (<code>SYS_EXIT</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a0</span>, <span style="color:#ae81ff">4</span>                <span style="color:#75715e">; Put 4 into a0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addiw</span> <span style="color:#66d9ef">a7</span>, <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">29</span>        <span style="color:#75715e">; Add 29 to a7 to get 93 (SYS_EXIT)     ; 16-bits
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ecall</span>                   <span style="color:#75715e">; Do syscall
</span></span></span></code></pre></div><h2 id="abusing-elf-and-program-header-entries">Abusing ELF and Program Header Entries<a href="#abusing-elf-and-program-header-entries" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>If you&rsquo;ve read my article in tmp0ut, <a href="https://tmpout.sh/1/1.html">Dead Bytes</a>, you&rsquo;ll be familiar with the entries of the ELF and program headers that are ignored by the Linux ELF loader. We can use these unchecked fields to store some of our instructions - as long as we leave at least 2 bytes free at the end of each run for a compressed <code>c.j</code> instruction!</p>
<p>The first decent run we have begins at offset 4, where we have a full 12 bytes to play with. This is room for the first three instructions, with two spare bytes for the jump.</p>
<p>The next unused chunk is just after <code>e_phoff</code> in the ELF header at offset <code>0x28</code> where we have just 8 bytes. Here we can put the next two instructions in our <code>SYS_OPENAT</code> block followed by another compressed jump.</p>
<p>Lastly is room for 6 bytes just after <code>e_phnum</code> at offset <code>0x3a</code> which is just enough for the full-width <code>li a7, 56</code> load instruction followed by the compressed jump. At this point, our final jump just continues execution after the end of the program header where the rest of the instructions are.</p>
<p>After putting everything in its rightful place, we have two tasks left:</p>
<ol>
<li>Insert the three <code>c.j</code> instructions</li>
<li>Update all the <code>??</code> values now that we can pre-calculate all the offsets</li>
</ol>
<h2 id="compressed-jumps">Compressed Jumps<a href="#compressed-jumps" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Up until this point, I had been using the GNU Assembler (gas) to assemble the RISC-V instructions. However, when it came to the compressed jumps, I found that gas simply refused to emit them! It always gave me full-width 32-bit jumps, but I knew from the spec that <code>c.j</code> was a valid instruction.</p>
<p>My solution was to assemble them manually using the awesome capstone engine. The following python will try every possible 16-bit integer, attempt to disassemble it as a compressed RISC-V instruction and print it if matches the <code>c.j</code> mnemonic. Is there a better way of doing this? Almost certainly, but this is simple and it works.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> capstone <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>md <span style="color:#f92672">=</span> Cs(CS_ARCH_RISCV, CS_MODE_RISCV64 <span style="color:#f92672">|</span> CS_MODE_RISCVC)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0x10000</span>):
</span></span><span style="display:flex;"><span>    disas <span style="color:#f92672">=</span> md<span style="color:#f92672">.</span>disasm( int<span style="color:#f92672">.</span>to_bytes(i,<span style="color:#ae81ff">2</span>,<span style="color:#e6db74">&#39;little&#39;</span>), <span style="color:#ae81ff">0x1000</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> inst <span style="color:#f92672">in</span> disas:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> inst<span style="color:#f92672">.</span>mnemonic <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;c.j&#39;</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>hex(i)<span style="color:#e6db74">}</span><span style="color:#e6db74"> =&gt; </span><span style="color:#e6db74">{</span>inst<span style="color:#f92672">.</span>mnemonic<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>inst<span style="color:#f92672">.</span>op_str<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><blockquote>
<p>You will need to install capstone version <code>5.0.0-rc4</code> or later to use the <code>CS_ARCH_RISCV</code> machine. With <code>pip</code> it&rsquo;s just <code>pip install capstone==5.0.0-rc4</code>.</p>
</blockquote>
<p>Armed with all these possible instructions, simply <code>grep</code>ing the output for the precise jump offset required is enough to hardcode all the jumps in place.</p>
<h2 id="pre-calculating-the-remaining-offsets">Pre-calculating the remaining offsets<a href="#pre-calculating-the-remaining-offsets" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>The first value we need to update is the offset to the <code>pathname</code> in the <code>addiw a1, a1, ??</code> instruction. Before we can do this, we need to put the string <code>&quot;4\0&quot;</code> into memory. Very nearby is the <code>e_version</code> field, which also happens to not be checked. Setting this entry to <code>34 00</code> gives us our pathname string at offset <code>0x14</code>. The <code>auipc</code> instruction is now at offset <code>0x8</code> which is <code>12</code> bytes before the string. Therefore we update the <code>addiw</code> instruction to <code>addiw a1, a1, +12</code>. As <code>12 &lt;= 31</code>, this remains a 16-bit instruction.</p>
<p>The next value we need to tweak is the <code>flags</code> argument we put into the <code>a2</code> register. We want this value to be within <code>31</code> of the total file size. Well, our total size is now <code>142</code> which means we need <code>a2</code> to be in the range <code>113</code>-<code>175</code>. The other requirement on this value is that it <code>OR</code>s true with both <code>64</code> (<code>O_CREAT</code>) and <code>1</code> (<code>O_WRONLY</code>). One solution is simply <code>125</code>, so the load becomes <code>li a2, 125</code>.</p>
<p>Lastly is the buffer length in the <code>a2</code> register when we call <code>SYS_WRITE</code>. As we just set <code>a2</code> to <code>125</code> above, we know that we need to add <code>17</code> to the total filesize of <code>142</code>. Therefore the instruction becomes <code>addi a2, a2, 17</code>.</p>
<h2 id="altogether-now">Altogether Now!<a href="#altogether-now" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>At long last we&rsquo;re done! Here&rsquo;s is the final ELF:</p>
<pre tabindex="0"><code>┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 7f 45 4c 46 13 05 c0 f9 ┊ 97 05 00 00 b1 25 29 a8 │•ELF••××┊×•⋄⋄×%)×│
│00000010│ 02 00 f3 00 34 00 58 58 ┊ 04 00 01 00 00 00 00 00 │•⋄×⋄4⋄XX┊•⋄•⋄⋄⋄⋄⋄│
│00000020│ 40 00 00 00 00 00 00 00 ┊ 13 06 d0 07 85 46 31 a0 │@⋄⋄⋄⋄⋄⋄⋄┊••×•×F1×│
│00000030│ 05 00 00 00 40 00 38 00 ┊ 01 00 93 08 80 03 2d a8 │•⋄⋄⋄@⋄8⋄┊•⋄×•×•-×│
│00000040│ 01 00 00 00 05 00 00 00 ┊ 00 00 00 00 00 00 00 00 │•⋄⋄⋄•⋄⋄⋄┊⋄⋄⋄⋄⋄⋄⋄⋄│
│00000050│ 00 00 01 00 00 00 00 00 ┊ 00 00 01 00 00 00 00 00 │⋄⋄•⋄⋄⋄⋄⋄┊⋄⋄•⋄⋄⋄⋄⋄│
│00000060│ 8a 00 00 00 00 00 00 00 ┊ 8a 00 00 00 00 00 00 00 │×⋄⋄⋄⋄⋄⋄⋄┊×⋄⋄⋄⋄⋄⋄⋄│
│00000070│ 00 10 00 00 00 00 00 00 ┊ 73 00 00 00 b1 15 45 06 │⋄•⋄⋄⋄⋄⋄⋄┊s⋄⋄⋄×•E•│
│00000080│ a1 28 73 00 00 00 11 45 ┊ f5 28 73 00 00 00       │×(s⋄⋄⋄•E┊×(s⋄⋄⋄  │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘
</code></pre><p>Let&rsquo;s break it all down:</p>
<pre tabindex="0"><code>7f454c46                                    ; ELF Magic \x7fELF
1305c0f9 97050000 b125 29a8                 ; Code Block 1
0200                                        ; e_type:       ET_EXEC
f300                                        ; e_machine:    EM_RISCV
3400                                        ; pathname:     &#34;4\x00&#34;
5858                                        ; unused
0400010000000000                            ; e_entry:      0x10004
4000000000000000                            ; e_phoff:      0x40
1306d007 8546 31a0                          ; Code Block 2
05000000                                    ; e_flags:      EF_RISCV_RVC | EF_RISCV_FLOAT_ABI_DOUBLE
4000                                        ; e_ehsize:     0x40
3800                                        ; e_phentsize:  0x38
0100                                        ; e_phnum:      0x01
93088003 2da8                               ; Code Block 3
01000000                                    ; p_type:       PT_LOAD
05000000                                    ; p_flags:      PF_X | PF_R
0000000000000000                            ; p_offset:     0x0
0000010000000000                            ; p_vaddr:      0x10000
0000010000000000                            ; p_paddr:      0x10000
8a00000000000000                            ; p_filesz:     0x8a = 142 - 4
8a00000000000000                            ; p_memsz:      0x8a = 142 - 4
0010000000000000                            ; p_align:      0x1000
73000000                                    ; Code Block 4
b115 4506 a128 73000000 1145 f528 73000000
</code></pre><p>The code blocks disassemble to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e">; Code Block 1 @ Offset 0x4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span>, <span style="color:#66d9ef">a0</span>, -<span style="color:#ae81ff">100</span>        <span style="color:#75715e">; Arg1 (dirfd) = AT_FDCWD
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">auipc</span> <span style="color:#66d9ef">a1</span>, <span style="color:#ae81ff">0x0</span>       <span style="color:#75715e">; a1 = pc + 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addiw</span> <span style="color:#66d9ef">a1</span>, <span style="color:#66d9ef">a1</span>, <span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">12</span>   <span style="color:#75715e">; Arg2 (pathname) = pc + 12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">c.j</span> <span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x1a</span>           <span style="color:#75715e">; Jump to file offset 0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; Code Block 2 @ Offset 0x28
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a2</span>, <span style="color:#ae81ff">125</span>          <span style="color:#75715e">; Arg3 (flags) = O_CREAT | O_WRONLY | 61
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a3</span>, <span style="color:#ae81ff">1</span>            <span style="color:#75715e">; Arg4 (mode) = O_WRONLY
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">c.j</span> <span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0xc</span>            : <span style="color:#66d9ef">Jump</span> <span style="color:#66d9ef">to</span> <span style="color:#66d9ef">file</span> <span style="color:#66d9ef">offset</span> <span style="color:#ae81ff">0x3a</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; Code Block 3 @ Offset 0x3a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">56</span>           <span style="color:#75715e">; Syscall = 56 (SYS_OPENAT)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">c.j</span> <span style="color:#960050;background-color:#1e0010">+</span><span style="color:#ae81ff">0x3a</span>           <span style="color:#75715e">; Jump to file offset 0x78
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">; Code Block 4 @ Offset 0x78
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ecall</span>               <span style="color:#75715e">; Do the syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addi</span> <span style="color:#66d9ef">a1</span>, <span style="color:#66d9ef">a1</span>, -<span style="color:#ae81ff">20</span>    <span style="color:#75715e">; Arg2 (buf) = 0x10000
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addi</span> <span style="color:#66d9ef">a2</span>, <span style="color:#66d9ef">a2</span>, <span style="color:#ae81ff">17</span>     <span style="color:#75715e">; Arg3 (len) = 142
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addiw</span> <span style="color:#66d9ef">a7</span>, <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">8</span>     <span style="color:#75715e">; Syscall = 64 (SYS_WRITE)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ecall</span>               <span style="color:#75715e">; Do the syscall
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a0</span>, <span style="color:#ae81ff">4</span>            <span style="color:#75715e">; Arg1 (ret) = 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">addiw</span> <span style="color:#66d9ef">a7</span>, <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">29</span>    <span style="color:#75715e">; Syscall = 93 (SYS_EXIT)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">ecall</span>               <span style="color:#75715e">; Do the syscall
</span></span></span></code></pre></div><p>And here&rsquo;s the final proof:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ make
</span></span><span style="display:flex;"><span>rm -f <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>nasm -f bin -o elf elf.asm
</span></span><span style="display:flex;"><span>./elf <span style="color:#f92672">||</span> /bin/true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sha256sum elf <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>001709c49a83c14cdad71d0182d62bdb33a3f43647d867299208a6a899deb422  elf
</span></span><span style="display:flex;"><span>001709c49a83c14cdad71d0182d62bdb33a3f43647d867299208a6a899deb422  <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls -la elf
</span></span><span style="display:flex;"><span>-rwxrwxr-x <span style="color:#ae81ff">1</span> ubuntu ubuntu <span style="color:#ae81ff">142</span> Aug <span style="color:#ae81ff">19</span> 17:27 elf
</span></span></code></pre></div><h1 id="conclusion">Conclusion<a href="#conclusion" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h1>
<p>This year&rsquo;s theme was a lot of fun to get stuck into. If you made it this far then you can see I had quite a few ideas for how best to go about constructing an entry, but the most important part is that I learnt a lot fleshing out each idea.</p>
<p>Similar to previous years, I didn&rsquo;t actually submit any of these entries for scoring as I actually help out with scoring other people&rsquo;s entries with the Binary Golf Association.</p>
<p>If you didn&rsquo;t submit an entry this year, keep an eye out for BGGP5 next year! I really can&rsquo;t recommend it enough :)</p>
<p>Until next time&hellip;</p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        
        <span class="button next">
            <a href="/posts/tetsuji/">
                <span class="button__text">Tetsuji: Remote Code Execution on a GameBoy Colour 22 Years Later</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Harvey Phillips 2020 - London, England</span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>

<div class="footer__webring">
    <span>
        <div>
            this site is part of the <a href='https://pixeldreams.tokyo/cgi-bin/webring.cgi'>HauNTed wEbriNg</a>
        </div>
        <div>
            <p>
                <a href='https://pixeldreams.tokyo/cgi-bin/webring.cgi?before=https://xcellerator.github.io/'>&lt;&lt;&lt;</a>
                <a href='https://pixeldreams.tokyo/cgi-bin/webring.cgi?random=https://xcellerator.github.io/'>RaNDom</a>
                <a href='https://pixeldreams.tokyo/cgi-bin/webring.cgi?after=https://xcellerator.github.io/'>&gt;&gt;&gt;</a>
            </p>
        </div>
    </span>
</div>





  
</div>

</body>
</html>
